{"version":3,"file":"static/js/591.84a78ed7.chunk.js","mappings":"6MAKMA,GAAOC,EAAAA,EAAAA,OAAK,kBAAM,wBAAiB,IA6CzC,EA3C2K,SAAH,GAAmE,IAA9DC,EAAe,EAAfA,gBAAiBC,EAAkB,EAAlBA,mBAAmBC,EAAmB,EAAnBA,oBAE7M,GAAgEC,EAAAA,EAAAA,YAAWC,EAAAA,GAApEC,EAAQ,EAARA,SAASC,EAAiB,EAAjBA,kBAAkBC,EAAc,EAAdA,eAAeC,EAAW,EAAXA,YAC3CC,GAAWC,EAAAA,EAAAA,UAEXC,GAAqBC,EAAAA,EAAAA,cAAY,SAACC,GACjCJ,EAASK,SAASL,EAASK,QAAQC,aACtCN,EAASK,QAAU,IAAIE,sBAAqB,SAAAC,GACrCA,EAAQ,GAAGC,gBAEVZ,GAAkB,SAAAa,GAAS,OAAIA,EAAY,CAAC,GAEpD,IAEGN,GAAMJ,EAASK,QAAQM,QAAQP,EAEtC,GAAE,CAACN,IASH,OAPAc,EAAAA,EAAAA,YAAU,WACNC,YAAW,WACPrB,EAAmBI,EACvB,GAAE,IAEN,GAAE,CAACA,KAGC,gBAAKkB,UAAU,gBAAe,UACxBf,GAAeR,EAAgBwB,OAAS,EAAIxB,EAAgByB,KAAI,SAACC,EAAKC,GACpE,OAAG3B,EAAgBwB,SAAWG,EAAQ,GAC1B,SAAC,EAAAC,SAAQ,CAAaC,UAAU,gDAA6B,UAAC,iBAAKC,IAAKnB,EAAmB,eAAI,SAACb,EAAI,CAACiC,aAAc7B,EAAqB8B,KAAMN,EAAKM,KAAMC,IAAKP,EAAKO,IAAKN,MAAOA,IAAS,QAAzKA,IAEf,SAAC,EAAAC,SAAQ,CAAaC,UAAU,gDAA6B,UAAC,SAAC/B,EAAI,CAACiC,aAAc7B,EAAsB8B,KAAMN,EAAKM,KAAMC,IAAKP,EAAKO,IAAKN,MAAOA,KAAhIA,EAG/B,KAAI,2BAC8B,IAA3B3B,EAAgBwB,SAAgB,8CACjC,gBAAKD,UAAU,kBAAkBW,IAAKC,QAKxD,C","sources":["components/pokemonList/index.tsx"],"sourcesContent":["import { FC, useCallback, useContext, useEffect, useRef, Suspense, lazy } from \"react\"\nimport { DataProviderContext } from \"../../contexts/dataProvider\"\nimport { IDetail, IPokemon } from \"../../types/pokemon\"\nimport pokeballImg from \"../../assets/pokeball.png\"\nimport \"./index.css\"\nconst Item = lazy(() => import(\"../item\")) \n\nconst PokemonList: FC<{currentPokemons: IPokemon[], setCurrentPokemons: React.Dispatch<React.SetStateAction<IPokemon[]>>, handlerSelectedItem: (item: IDetail) => void}> = ({currentPokemons, setCurrentPokemons,handlerSelectedItem}) => {\n\n    const {pokemons,setCountNextFetch,countNextFetch,isSearching} = useContext(DataProviderContext)\n    const observer = useRef<any>()\n\n    const lastPokemonItemRef = useCallback((node: any) => {\n        if(observer.current) observer.current.disconnect()\n        observer.current = new IntersectionObserver(entries => {\n            if(entries[0].isIntersecting)\n            {\n                setCountNextFetch(prevState => prevState + 1)\n            }\n        })\n\n        if(node) observer.current.observe(node)\n\n    },[countNextFetch])\n\n    useEffect(() => {\n        setTimeout(() => {\n            setCurrentPokemons(pokemons)\n        },2000)\n        \n    },[pokemons])\n\n    return (\n        <div className='listContainer' >\n            {!isSearching && currentPokemons.length > 0 ? currentPokemons.map((item,index) =>{\n                if(currentPokemons.length === index + 1){\n                    return  <Suspense key={index} fallback={<h1>LOADDING POKEMON...</h1>}><div ref={lastPokemonItemRef}  > <Item handlerClick={handlerSelectedItem} name={item.name} url={item.url} index={index} /> </div></Suspense> \n                } else {\n                    return  <Suspense key={index} fallback={<h1>LOADDING POKEMON...</h1>}><Item handlerClick={handlerSelectedItem}  name={item.name} url={item.url} index={index} /></Suspense> \n                }\n                \n            }): <div> \n                  {currentPokemons.length === 0 && <h1>No pokemon found</h1>}\n                  <img className=\"pokeballLoading\" src={pokeballImg} />\n                </div>}\n            \n        </div>\n    )\n}\n\nexport default PokemonList"],"names":["Item","lazy","currentPokemons","setCurrentPokemons","handlerSelectedItem","useContext","DataProviderContext","pokemons","setCountNextFetch","countNextFetch","isSearching","observer","useRef","lastPokemonItemRef","useCallback","node","current","disconnect","IntersectionObserver","entries","isIntersecting","prevState","observe","useEffect","setTimeout","className","length","map","item","index","Suspense","fallback","ref","handlerClick","name","url","src","pokeballImg"],"sourceRoot":""}